
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
        <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>ShutTUM.sequence &#8212; ShutTUM 1.1 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
    <script type="text/javascript" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ShutTUM.sequence</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">yaml</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">p</span>
<span class="kn">import</span> <span class="nn">numpy</span>   <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">ShutTUM.devices</span>
<span class="kn">import</span> <span class="nn">ShutTUM.values</span>


<div class="viewcode-block" id="Sequence"><a class="viewcode-back" href="../../sequence.html#ShutTUM.sequence.Sequence">[docs]</a><span class="k">class</span> <span class="nc">Sequence</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The base class representing one dataset sequence.</span>
<span class="sd">    </span>
<span class="sd">    In order for performent operations the sequence loads and checks lots of the data in its :any:`__init__` thus avoiding</span>
<span class="sd">    expensive checks in for loops or list comprehensions. In addition it holds the reference to list-like objects, such </span>
<span class="sd">    as :any:`cameras` or :any:`imu &lt;ShutTUM.Sequence.imu&gt;`. You can iterate over each of these (depending</span>
<span class="sd">    on application) to get the corresponding :any:`Value` s in order.</span>
<span class="sd">    </span>
<span class="sd">    A typical application might look like::</span>
<span class="sd">    </span>
<span class="sd">        # Load a dataset&#39;s sequence</span>
<span class="sd">        sequence = Sequence(&#39;path/to/folder/01&#39;)</span>
<span class="sd">        </span>
<span class="sd">        # Iterate over all imu values and find corresponding images</span>
<span class="sd">        for observation in sequence.imu:</span>
<span class="sd">            </span>
<span class="sd">            print(observation.acceleration)</span>
<span class="sd">            print(observation.angular_velocity)</span>
<span class="sd">            </span>
<span class="sd">            stereo = observation.stereo(shutter=&#39;global&#39;)</span>
<span class="sd">            if stereo is None: continue</span>
<span class="sd">            </span>
<span class="sd">            print(stereo.L.ID)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_Data</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Data&#39;</span><span class="p">,</span> <span class="s1">&#39;global_ rolling imu groundtruth stamp&#39;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_folder_exists</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Checks if a folder exists and raises an exception otherwise</span>
<span class="sd">        :param str folder: the path to the folder to check for existance</span>
<span class="sd">        :raises IOError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">folder</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Could not find folder </span><span class="si">%s</span><span class="s2">, record folder seems not to be valid!&quot;</span> <span class="o">%</span> <span class="n">folder</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_file_exists</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Checks if a file exists and raises an exception otherwise</span>
<span class="sd">        :param str file: the path to the file to check for existance</span>
<span class="sd">        :raises IOError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">file</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Could not find </span><span class="si">%s</span><span class="s2">, record folder seems not to be valid!&quot;</span> <span class="o">%</span> <span class="n">file</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_check_contains_key</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str file: The reference file, which to give in the error message</span>
<span class="sd">        :param dict dictionary: the dict to check the key&#39;s existance</span>
<span class="sd">        :param str key: the key to check for </span>
<span class="sd">        :raises ValueError</span>
<span class="sd">        </span>
<span class="sd">        Checks if a dict originating from a certain file contains a certain key and raises an exception otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not find </span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">, record folder seems not to be valid!&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">file</span><span class="p">))</span>

<div class="viewcode-block" id="Sequence.__init__"><a class="viewcode-back" href="../../sequence.html#ShutTUM.sequence.Sequence.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">stereosync</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">calibration</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        :param str path: the path to one sequence of the dataset, such as ``~/ShutTUM/0001``</span>
<span class="sd">        :param bool stereosync: possiblity to set the :any:`stereosync` option in constructor</span>
<span class="sd">        :param bool calibration: is this a calibration sequence? If yes, ``cam1`` and ``cam2`` are used as ``global`` </span>
<span class="sd">        while ``cam3`` and ``cam4`` are set under the ``rolling`` namespace </span>
<span class="sd">        :raises: ValueError: if anything goes wrong </span>
<span class="sd">        Load the sequence into memory (except images) and do basic data consistency checks.</span>
<span class="sd">        </span>
<span class="sd">        1. It is checked that in path there exists a ``data``, ``frames`` and ``params`` folder</span>
<span class="sd">        2. It is checked that there exists the files ``data/frames.csv``, ``data/imu.csv`` and ``data/ground_truth.csv``</span>
<span class="sd">        3. The files from 2. are loaded into memory (see :any:`raw`)</span>
<span class="sd">        4. The ``params/time.yaml`` is loaded</span>
<span class="sd">        5. The ``params/params.yaml`` is loaded</span>
<span class="sd">           </span>
<span class="sd">        .. seealso:: :any:`stereosync`</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">expandvars</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">expanduser</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync</span> <span class="o">=</span> <span class="n">stereosync</span>

        <span class="c1"># Consistency Check</span>
        <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_folder_exists</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">))</span>
        <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_folder_exists</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;frames&#39;</span><span class="p">))</span>
        <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_folder_exists</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;params&#39;</span><span class="p">))</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;frames.csv&#39;</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;imu.csv&#39;</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;data&#39;</span><span class="p">,</span> <span class="s1">&#39;ground_truth.csv&#39;</span><span class="p">)</span>

        <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_file_exists</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_file_exists</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_file_exists</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_frames</span>       <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="c1">#, dtype=(float, int, float, str))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_imu</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ground_truth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_times</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frames</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_imu</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_ground_truth</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])))</span>

        <span class="n">Raw</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Raw&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;frames&#39;</span><span class="p">,</span> <span class="s1">&#39;imu&#39;</span><span class="p">,</span> <span class="s1">&#39;groundtruth&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span> <span class="o">=</span> <span class="n">Raw</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_frames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ground_truth</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">timefile</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;params&#39;</span><span class="p">,</span> <span class="s1">&#39;time.yaml&#39;</span><span class="p">)</span>
        <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_file_exists</span><span class="p">(</span><span class="n">timefile</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">timefile</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">)[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span>
            <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_contains_key</span><span class="p">(</span><span class="n">timefile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">)</span>
            <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_contains_key</span><span class="p">(</span><span class="n">timefile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">)</span>
            <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_contains_key</span><span class="p">(</span><span class="n">timefile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">,</span> <span class="s1">&#39;duration&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">paramfile</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;params&#39;</span><span class="p">,</span> <span class="s1">&#39;params.yaml&#39;</span><span class="p">)</span>
        <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_file_exists</span><span class="p">(</span><span class="n">paramfile</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">paramfile</span><span class="p">)</span> <span class="k">as</span> <span class="n">stream</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_refs</span> <span class="o">=</span> <span class="n">yaml</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">stream</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">calibration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_refs</span><span class="p">[</span><span class="s1">&#39;cam1&#39;</span><span class="p">][</span><span class="s1">&#39;shutter&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;global&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_refs</span><span class="p">[</span><span class="s1">&#39;cam2&#39;</span><span class="p">][</span><span class="s1">&#39;shutter&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;global&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_refs</span><span class="p">[</span><span class="s1">&#39;cam3&#39;</span><span class="p">][</span><span class="s1">&#39;shutter&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;rolling&#39;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_refs</span><span class="p">[</span><span class="s1">&#39;cam4&#39;</span><span class="p">][</span><span class="s1">&#39;shutter&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;rolling&#39;</span>
                <span class="c1"># TODO add doc string for this</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_gammas</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ref</span> <span class="o">==</span> <span class="s1">&#39;world&#39;</span><span class="p">:</span> <span class="k">continue</span>  <span class="c1"># world param must only be present, not more</span>

            <span class="c1"># Every other reference must have at least a transform parameter</span>
            <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_contains_key</span><span class="p">(</span><span class="n">paramfile</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refs</span><span class="p">[</span><span class="n">ref</span><span class="p">],</span> <span class="s1">&#39;transform&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="s1">&#39;shutter&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refs</span><span class="p">[</span><span class="n">ref</span><span class="p">]:</span> <span class="k">continue</span>

            <span class="c1"># If the reference contains a &#39;shutter&#39; param, it is a camera</span>
            <span class="n">cam</span> <span class="o">=</span> <span class="n">ref</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span><span class="p">[</span><span class="n">cam</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_refs</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span>

            <span class="n">folder</span>   <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span>   <span class="s1">&#39;params&#39;</span><span class="p">,</span> <span class="n">cam</span><span class="p">)</span>
            <span class="n">gamma</span>    <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s1">&#39;gamma.txt&#39;</span><span class="p">)</span>
            <span class="n">vignette</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder</span><span class="p">,</span> <span class="s1">&#39;vignette.png&#39;</span><span class="p">)</span>
            <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_folder_exists</span><span class="p">(</span><span class="n">folder</span><span class="p">)</span>
            <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_file_exists</span><span class="p">(</span><span class="n">gamma</span><span class="p">)</span>
            <span class="n">Sequence</span><span class="o">.</span><span class="n">_check_file_exists</span><span class="p">(</span><span class="n">vignette</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gammas</span><span class="p">[</span><span class="n">cam</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
</div>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cameras</span> <span class="o">=</span> <span class="n">ShutTUM</span><span class="o">.</span><span class="n">devices</span><span class="o">.</span><span class="n">DuoStereoCamera</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;The path to this sequence. Environment variables get expanded automatically&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The raw values in matrix form. This property is a Named Tuple with the following fields:</span>
<span class="sd">        </span>
<span class="sd">        * ``frames`` (`ndarray &lt;https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html&gt;`_) corresponding to ``data/frames.csv``</span>
<span class="sd">        * ``imu`` (`ndarray &lt;https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html&gt;`_) corresponding to ``data/imu.csv``</span>
<span class="sd">        * ``groundtruth`` (`ndarray &lt;https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html&gt;`_) corresponding to ``data/ground_truth.csv``</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_raw</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">stereosync</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enables/Disables frame synchronization between cameras. (default ``True``)</span>
<span class="sd">        </span>
<span class="sd">        When working with stereo images you obviously need two images. Sometimes, however, one camera has recorded a </span>
<span class="sd">        frame while its :any:`opposite` has dropped a frame. With the ``stereosync`` option you can specify how to </span>
<span class="sd">        handle these frame drops. </span>
<span class="sd">             </span>
<span class="sd">        .. image:: images/stereosync.svg</span>
<span class="sd">        </span>
<span class="sd">        With ``stereosync`` enabled, you iterate only over frames which have been captured by *both* cameras. With</span>
<span class="sd">        stereosync disabled, you iterate over all stereo images which have *at least one* camera captured an image. If both </span>
<span class="sd">        cams occurred to drop the same frame, this will be skipped in the iterations. The dropped :any:`Image` is set</span>
<span class="sd">        to None::</span>
<span class="sd">        </span>
<span class="sd">            sequence.stereosync = False</span>
<span class="sd">            </span>
<span class="sd">            left_drops, right_drops = [], []</span>
<span class="sd">            for stereo in sequence.cameras(&#39;global&#39;):</span>
<span class="sd">                if stereo.L is None: left_drops.append(stereo.ID)</span>
<span class="sd">                if stereo.R is None: right_drops.append(stereo.ID)</span>
<span class="sd">                </span>
<span class="sd">            print(&#39;Left Camera dropped frames:  %s&#39; % left_drops)</span>
<span class="sd">            print(&#39;Right Camera dropped frames: %s&#39; % right_drops)</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sync</span>

    <span class="nd">@stereosync</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">stereosync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sync</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="Sequence.cameras"><a class="viewcode-back" href="../../sequence.html#ShutTUM.sequence.Sequence.cameras">[docs]</a>    <span class="k">def</span> <span class="nf">cameras</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shutter</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        :param str shutter: {both/global/rolling} the type of shutter you are interested in.</span>
<span class="sd">        :return: The reference of the cameras, which you can iterate either as :any:`StereoCamera` (global/rolling)or :any:`DuoStereoCamera` (both)</span>
<span class="sd">        :raise: ValueError: for anything other then both/global/rolling</span>
<span class="sd">        </span>
<span class="sd">        Get a reference to one or both of the two stereo cameras, to iterate over their images</span>
<span class="sd">        </span>
<span class="sd">        Note that often you want to directly iterate over those references, which you can do like::</span>
<span class="sd">        </span>
<span class="sd">            # Iterate over both rolling and global images</span>
<span class="sd">            for g, r in sequence.cameras(shutter=&#39;both&#39;):</span>
<span class="sd">                print(g.L.ID)</span>
<span class="sd">                print(r.R.stamp)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        .. seealso:: :any:`ShutTUM.Sequence.stereosync`</span>
<span class="sd">       </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">shutter</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span><span class="p">:</span>    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cameras</span>
        <span class="k">if</span> <span class="n">shutter</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span><span class="p">:</span>  <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cameras</span><span class="o">.</span><span class="n">_global</span>
        <span class="k">if</span> <span class="n">shutter</span> <span class="o">==</span> <span class="s1">&#39;rolling&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cameras</span><span class="o">.</span><span class="n">_rolling</span>
</div>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown shutter type: use either &quot;global&quot;, &quot;rolling&quot;, or &quot;both&quot; and not </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">shutter</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">imu</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        :return: Generator property, yielding one :any:`Imu` after the other</span>
<span class="sd">        </span>
<span class="sd">        This property is a python generator, which you can use to iterate over all available</span>
<span class="sd">        :any:`Imu` s in this sequence. Note that generators do not support indexing. </span>
<span class="sd">        </span>
<span class="sd">        Note that often you want to directly iterate over the Imu like so::</span>
<span class="sd">            </span>
<span class="sd">            # Iterate over all imu values</span>
<span class="sd">            for observation in sequence.imu:</span>
<span class="sd">                print(observation.acceleration)</span>
<span class="sd">                </span>
<span class="sd">            # When you want e.g. the first imu value use:</span>
<span class="sd">            first_imu = next(sequence.imu)</span>
<span class="sd">            </span>
<span class="sd">            # When you absolutely need indexing convert the generator to a in memory list first</span>
<span class="sd">            imus = list(sequence.imu)</span>
<span class="sd">            print(imus[17].stamp)</span>
<span class="sd">            </span>
<span class="sd">            # Use the usual python &quot;functional&quot; shenanigans</span>
<span class="sd">            imus_up_to_10s = filter(lambda imu: imu.stamp &lt;= 10, sequence.imu)</span>
<span class="sd">            imus_up_to_10s = [ imu for imu in sequence.imu if imu.stamp &lt;= 10 ]</span>
<span class="sd">            </span>
<span class="sd">            acc_in_g = map(lambda imu: imu.acceleration * 9.805, sequence.imu)</span>
<span class="sd">            acc_in_g = [ imu.acceleration * 9.805 for imu in sequence.imu ]</span>
<span class="sd">            </span>
<span class="sd">            # Note that generators don&#39;t implement __len__()</span>
<span class="sd">            # to get the amount of imu values in this sequence either use</span>
<span class="sd">            N = len(list(sequence.imu))               # or:</span>
<span class="sd">            N = sum([ 1 for value in sequence.imu ])  # which is the same as:</span>
<span class="sd">            N = sequence.raw.imu.shape[0]</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">imu</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">ShutTUM</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">Imu</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mocap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        :return: Generator property, yielding one :any:`GroundTruth` value after the other</span>

<span class="sd">        This property is a python generator, which you can use to iterate over all available</span>
<span class="sd">        :any:`GroundTruth` s in this sequence. Note that generators do not support indexing. </span>

<span class="sd">        Note that often you want to directly iterate over the Mocap like so::</span>

<span class="sd">           # Iterate over all ground truth values</span>
<span class="sd">           for gt in sequence.mocap:</span>
<span class="sd">               c1_T_w = gt &gt;&gt; &#39;cam1&#39;   # pose of cam1 in world frame</span>

<span class="sd">           # When you want e.g. the first ground truth value use:</span>
<span class="sd">           first_gt = next(sequence.mocap)</span>

<span class="sd">           # When you absolutely need indexing convert the generator to a in memory list first</span>
<span class="sd">           gts = list(sequence.mocap)</span>
<span class="sd">           print(gts[17].stamp)</span>

<span class="sd">           # Use the usual python &quot;functional&quot; shenanigans</span>
<span class="sd">           gts_from_10s = filter(lambda gt: gt.stamp &gt;= 10, sequence.mocap)</span>
<span class="sd">           gts_from_10s = [ gt for gt in sequence.mocap if gt.stamp &gt;= 10 ]</span>

<span class="sd">           # Note that generators don&#39;t implement __len__()</span>
<span class="sd">           # to get the amount of imu values in this sequence either use</span>
<span class="sd">           N = len(list(sequence.mocap))               # or:</span>
<span class="sd">           N = sum([ 1 for value in sequence.mocap ])  # which is the same as:</span>
<span class="sd">           N = sequence.raw.groundtruth.shape[0]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">groundtruth</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">ShutTUM</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">GroundTruth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">times</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A list of all time stamps in this sequence.</span>
<span class="sd">        </span>
<span class="sd">        .. math:: \mathbf{t} = \mathbf{t}_{frames} \cup \mathbf{t}_{imu} \cup \mathbf{t}_{groundtruth}</span>
<span class="sd">        </span>
<span class="sd">        Note that this list is sorted, so you can easily iterate over it like so::</span>
<span class="sd">        </span>
<span class="sd">            for time in sequence.times:</span>
<span class="sd">                print(time)</span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The start time of the record as Unix Timestamp in seconds with decimal places</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="s1">&#39;start&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The end time of the record as Unix Timestamp in seconds with decimal places</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="s1">&#39;end&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        The duration of the record in seconds as float, so basically:</span>
<span class="sd">        ``sequence.end - sequence.start``</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the resolution of the cameras as a named tuple ``Resolution (width, height)`` &quot;&quot;&quot;</span>
        <span class="n">Resolution</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Resolution&#39;</span><span class="p">,</span> <span class="s1">&#39;width height&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Resolution</span><span class="p">(</span><span class="n">width</span><span class="o">=</span><span class="mi">1280</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">1024</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exposure_limits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: a Namped Tuple ``Limits(min, max)`` indicating the minimum</span>
<span class="sd">        and maximum exposure time in milliseconds which occurred during this sequence</span>
<span class="sd">        </span>
<span class="sd">        The minimal &amp; maximal exposure used for all cameras. Note that these values are the *limits*</span>
<span class="sd">        not the extrema of the record, so most of the time, these will not be reached, but if, clamped accordingly.::</span>
<span class="sd">        </span>
<span class="sd">            limits = sequence.exposure_limits</span>
<span class="sd">            print(&quot;Limits are %s .. %s ms&quot; % (limits.min, limits.max))</span>
<span class="sd">            </span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Limits</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Limits&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">cam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span><span class="p">:</span>
            <span class="c1"># take the first camera, since all limits are the same</span>
            <span class="n">exp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span><span class="p">[</span><span class="n">cam</span><span class="p">][</span><span class="s1">&#39;exposure&#39;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">Limits</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="n">exp</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">],</span> <span class="nb">max</span><span class="o">=</span><span class="n">exp</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="Sequence.gamma"><a class="viewcode-back" href="../../sequence.html#ShutTUM.sequence.Sequence.gamma">[docs]</a>    <span class="k">def</span> <span class="nf">gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cam</span><span class="p">,</span> <span class="nb">input</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; </span>
<span class="sd">        :param str cam: the name of the camera (e.g. ``&quot;cam1&quot;``)</span>
<span class="sd">        :param float input: the position to lookup, i.e. X-axis on luminance plot. Between 0 .. 255, will be rounded to int</span>
<span class="sd">        :raises: ValueError: for unknown camera names or inputs below 0 or above 255</span>
<span class="sd">        </span>
<span class="sd">        Lookup a gamma value from ``params/&lt;cam&gt;/gamma.txt``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown camera name: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cam</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">input</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">input</span> <span class="o">&gt;</span> <span class="mi">255</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Gamma function only defined for inputs from 0 .. 255 and not for </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">input</span><span class="p">)</span></div>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gammas</span><span class="p">[</span><span class="n">cam</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="nb">input</span><span class="p">))]</span>

<div class="viewcode-block" id="Sequence.vignette"><a class="viewcode-back" href="../../sequence.html#ShutTUM.sequence.Sequence.vignette">[docs]</a>    <span class="k">def</span> <span class="nf">vignette</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cam</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str cam: the name of the camera to lookup its vignette (e.g. ``&quot;cam1&quot;``)  </span>
<span class="sd">        :return: the vignette image, read by `cv2.imread() &lt;http://docs.opencv.org/3.0-beta/doc/py_tutorials/py_gui/py_image_display/py_image_display.html&gt;`_ with dimensions [1280x1024] as grayscale</span>
<span class="sd">        :rtype: `ndarray &lt;https://docs.scipy.org/doc/numpy-1.13.0/reference/generated/numpy.ndarray.html&gt;`_</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cam</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown camera name: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">cam</span><span class="p">)</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">,</span> <span class="s1">&#39;params&#39;</span><span class="p">,</span> <span class="n">cam</span><span class="p">,</span> <span class="s1">&#39;vignette.png&#39;</span><span class="p">)</span></div>
        <span class="k">return</span> <span class="n">cv2</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">cv2</span><span class="o">.</span><span class="n">IMREAD_GRAYSCALE</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rolling_shutter_speed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        How fast did the two rolling shutter cameras shuttered. Returns the time between the exposure of two consecutive </span>
<span class="sd">        rows in milli seconds (approximate)</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">cam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span><span class="p">:</span>
            <span class="n">shutter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span><span class="p">[</span><span class="n">cam</span><span class="p">][</span><span class="s1">&#39;shutter&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">shutter</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;rolling&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">shutter</span><span class="p">[</span><span class="s1">&#39;speed&#39;</span><span class="p">]</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No cams in </span><span class="si">%s</span><span class="s1"> had rolling shutter enabled!&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shutter_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Which shutter method uses each camera.</span>
<span class="sd">        </span>
<span class="sd">        Returns one of the two following dictionaries::</span>
<span class="sd">        </span>
<span class="sd">            # For sequences with odd ID</span>
<span class="sd">            {</span>
<span class="sd">                &#39;cam1&#39;: &#39;global&#39;</span>
<span class="sd">                &#39;cam2&#39;: &#39;global&#39;</span>
<span class="sd">                &#39;cam3&#39;: &#39;rolling&#39;</span>
<span class="sd">                &#39;cam4&#39;: &#39;rolling&#39;</span>
<span class="sd">            }</span>
<span class="sd">            </span>
<span class="sd">            # For sequences with even ID</span>
<span class="sd">            {</span>
<span class="sd">                &#39;cam1&#39;: &#39;rolling&#39;</span>
<span class="sd">                &#39;cam2&#39;: &#39;rolling&#39;</span>
<span class="sd">                &#39;cam3&#39;: &#39;global&#39;</span>
<span class="sd">                &#39;cam4&#39;: &#39;global&#39;</span>
<span class="sd">            }</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span> <span class="n">cam</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span><span class="p">[</span><span class="n">cam</span><span class="p">][</span><span class="s1">&#39;shutter&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">cam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span> <span class="p">}</span>

<div class="viewcode-block" id="Sequence.lookup_cam_name"><a class="viewcode-back" href="../../sequence.html#ShutTUM.sequence.Sequence.lookup_cam_name">[docs]</a>    <span class="k">def</span> <span class="nf">lookup_cam_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shutter</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Find the corresponding name of the camera for a given shutter and side</span>
<span class="sd">        </span>
<span class="sd">        :param shutter: either one of {``&quot;global&quot;``, ``&quot;rolling&quot;``} </span>
<span class="sd">        :param side: either one of {``&#39;L&#39;``, ``&#39;R&#39;`` }</span>
<span class="sd">        :return: one of {``&quot;cam1&quot;`` .. ``&quot;cam4&quot;``} or raises ValueError on invalid parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cams</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;shutter&#39;</span><span class="p">][</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">shutter</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cam1&#39;</span><span class="p">,</span> <span class="s1">&#39;cam4&#39;</span><span class="p">]:</span> <span class="k">return</span> <span class="n">name</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;R&#39;</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cam2&#39;</span><span class="p">,</span> <span class="s1">&#39;cam3&#39;</span><span class="p">]:</span> <span class="k">return</span> <span class="n">name</span>
</div>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> Cannot lookup cam name for shutter &quot;</span><span class="si">%s</span><span class="s1">&quot; on side &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shutter</span><span class="p">,</span> <span class="n">side</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_find_data_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">ShutTUM</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s1">&#39;world&#39;</span><span class="p">)</span>  <span class="c1"># world as dummy for the time stamp</span>
        <span class="k">return</span> <span class="n">Sequence</span><span class="o">.</span><span class="n">_Data</span><span class="p">(</span>
            <span class="n">stamp</span><span class="o">=</span><span class="n">s</span><span class="p">,</span>
            <span class="n">global_</span><span class="o">=</span><span class="n">ShutTUM</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">StereoImage</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;global&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">),</span>
            <span class="n">rolling</span><span class="o">=</span><span class="n">ShutTUM</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">StereoImage</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;rolling&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">),</span>
            <span class="n">imu</span><span class="o">=</span><span class="n">ShutTUM</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">Imu</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">),</span>
            <span class="n">groundtruth</span><span class="o">=</span><span class="n">ShutTUM</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">GroundTruth</span><span class="o">.</span><span class="n">extrapolate</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;exact&#39;</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_find_data_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">time</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_times</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">stop</span>  <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">time</span> <span class="o">&gt;</span> <span class="n">stop</span><span class="p">:</span>  <span class="k">continue</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_data_for</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

<div class="viewcode-block" id="Sequence.__getitem__"><a class="viewcode-back" href="../../sequence.html#ShutTUM.sequence.Sequence.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stamp</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param float/slice stamp: either the time at which to look up the values or a slice object (e.g. start:stop) </span>
<span class="sd">                                  defining a range of time stamps, between which to lookup the values. If the start </span>
<span class="sd">                                  value of the slice is before :any:`start`, or the end value of the slice is after </span>
<span class="sd">                                  :any:`end`, then the generator yield up to :any:`start` or :any:`end`, respectively.</span>
<span class="sd">                                  Note that times for the slice are both *inclusive* unlike normal python index slices.</span>
<span class="sd">        :return: either a named tuple with the fields </span>
<span class="sd">                  * ``stamp`` (float)</span>
<span class="sd">                  * ``global_`` (:any:`StereoImage`) </span>
<span class="sd">                  * ``rolling`` (:any:`StereoImage`) </span>
<span class="sd">                  * ``imu`` (:any:`Imu`) and </span>
<span class="sd">                  * ``groundtruth`` (:any:`GroundTruth`). </span>
<span class="sd">                 </span>
<span class="sd">                 or a generator yielding multiple (or none) of these. If any of the values of the above tuple does not </span>
<span class="sd">                 exist for the stamp, it becomes ``None``. Note the spelling of ``global_``, since ``global`` </span>
<span class="sd">                 is a reserved keyword in python.</span>
<span class="sd">        </span>
<span class="sd">        Looks up all corresponding :any:`Value` s it can find for a given time stamp::</span>
<span class="sd">        </span>
<span class="sd">            sequence = Sequence(...)</span>
<span class="sd">            </span>
<span class="sd">            # The single lookup with one float as index</span>
<span class="sd">            for time in sequence.times:</span>
<span class="sd">                data = sequence[time]</span>
<span class="sd">                if data.global_     is not None: print(data.global_.ID)</span>
<span class="sd">                if data.rolling     is not None: print(data.rolling.ID)</span>
<span class="sd">                if data.imu         is not None: print(data.imu.acceleration)</span>
<span class="sd">                if data.groundtruth is not None: print(data.groundtruth.marker)</span>
<span class="sd">        </span>
<span class="sd">            # ... or the sliced version specifying all data between 5s .. 45s</span>
<span class="sd">            for data in sequence[5:45]:</span>
<span class="sd">               print(data)</span>
<span class="sd">                </span>
<span class="sd">            # ... or all up to 10s</span>
<span class="sd">            for data in sequence[:10]:</span>
<span class="sd">                print(data)</span>
<span class="sd">                </span>
<span class="sd">            # ... or all from 30s till end</span>
<span class="sd">            for data in sequence[30:]:</span>
<span class="sd">                print(data)</span>
<span class="sd">                </span>
<span class="sd">            # Custom steps, however, are not supported:</span>
<span class="sd">            try:</span>
<span class="sd">                x = sequence[::-1]</span>
<span class="sd">            except ValueError:</span>
<span class="sd">                print(&quot;Doesn&#39;t make sense...&quot;)</span>
<span class="sd">        </span>
<span class="sd">                </span>
<span class="sd">            </span>
<span class="sd">        Note, though, that this is not the most performant thing to iterate over the sequence,</span>
<span class="sd">        since the lookup has to be done on every iteration. Consider iterating over :any:`cameras`, :any:`imu` or </span>
<span class="sd">        :any:`mocap` instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stamp</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">stamp</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">] Slicing a sequence with a step value like </span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1">:</span><span class="si">%s</span><span class="s1"> is not supported&#39;</span>
                                 <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stamp</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stamp</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">stamp</span><span class="o">.</span><span class="n">step</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_data_between</span><span class="p">(</span><span class="n">stamp</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">stamp</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span></div></div>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_data_for</span><span class="p">(</span><span class="n">stamp</span><span class="p">)</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">ShutTUM</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../sequence.html">Sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../devices.html">Devices</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../values.html">Values</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../downloads.html">Downloads</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  <li><a href="../ShutTUM.html">ShutTUM</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, Thore Goll.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>